CMake 生成器负责为底层构建系统编写输入文件 (例如 Makefile)。运行cmake --help将显示可用的生成器。对于 cmake version 4.2.1，我的系统支持的生成器包括：
```
Generators

The following generators are available on this platform (* marks default):
  Visual Studio 18 2026        = Generates Visual Studio 2026 project files.
                                 Use -A option to specify architecture.
  Visual Studio 17 2022        = Generates Visual Studio 2022 project files.
                                 Use -A option to specify architecture.
  Visual Studio 16 2019        = Generates Visual Studio 2019 project files.
                                 Use -A option to specify architecture.
  Visual Studio 15 2017        = Generates Visual Studio 2017 project files.
                                 Use -A option to specify architecture.
  Visual Studio 14 2015        = Deprecated.  Generates Visual Studio 2015
                                 project files.  Use -A option to specify
                                 architecture.
  Borland Makefiles            = Generates Borland makefiles.
* NMake Makefiles              = Generates NMake makefiles.
  NMake Makefiles JOM          = Generates JOM makefiles.
  MSYS Makefiles               = Generates MSYS makefiles.
  MinGW Makefiles              = Generates a make file for use with
                                 mingw32-make.
  Green Hills MULTI            = Generates Green Hills MULTI files
                                 (experimental, work-in-progress).
  Unix Makefiles               = Generates standard UNIX makefiles.
  Ninja                        = Generates build.ninja files.
  Ninja Multi-Config           = Generates build-<Config>.ninja files.
  FASTBuild                    = Generates fbuild.bff files.
  Watcom WMake                 = Generates Watcom WMake makefiles.
  CodeBlocks - MinGW Makefiles = Generates CodeBlocks project files
                                 (deprecated).
  CodeBlocks - NMake Makefiles = Generates CodeBlocks project files
                                 (deprecated).
  CodeBlocks - NMake Makefiles JOM
                               = Generates CodeBlocks project files
                                 (deprecated).
  CodeBlocks - Ninja           = Generates CodeBlocks project files
                                 (deprecated).
  CodeBlocks - Unix Makefiles  = Generates CodeBlocks project files
                                 (deprecated).
  CodeLite - MinGW Makefiles   = Generates CodeLite project files
                                 (deprecated).
  CodeLite - NMake Makefiles   = Generates CodeLite project files
                                 (deprecated).
  CodeLite - Ninja             = Generates CodeLite project files
                                 (deprecated).
  CodeLite - Unix Makefiles    = Generates CodeLite project files
                                 (deprecated).
  Eclipse CDT4 - NMake Makefiles
                               = Generates Eclipse CDT 4.0 project files
                                 (deprecated).
  Eclipse CDT4 - MinGW Makefiles
                               = Generates Eclipse CDT 4.0 project files
                                 (deprecated).
  Eclipse CDT4 - Ninja         = Generates Eclipse CDT 4.0 project files
                                 (deprecated).
  Eclipse CDT4 - Unix Makefiles= Generates Eclipse CDT 4.0 project files
                                 (deprecated).
  Kate - MinGW Makefiles       = Generates Kate project files (deprecated).
  Kate - NMake Makefiles       = Generates Kate project files (deprecated).
  Kate - Ninja                 = Generates Kate project files (deprecated).
  Kate - Ninja Multi-Config    = Generates Kate project files (deprecated).
  Kate - Unix Makefiles        = Generates Kate project files (deprecated).
  Sublime Text 2 - MinGW Makefiles
                               = Generates Sublime Text 2 project files
                                 (deprecated).
  Sublime Text 2 - NMake Makefiles
                               = Generates Sublime Text 2 project files
                                 (deprecated).
  Sublime Text 2 - Ninja       = Generates Sublime Text 2 project files
                                 (deprecated).
  Sublime Text 2 - Unix Makefiles
                               = Generates Sublime Text 2 project files
                                 (deprecated).
```

可以看到Ninja也是基于cmake跨平台的, ninja就是cmake其中支持的生成器.

Ninja(忍者) 由谷歌开发, 是一个更高性能的构建系统
- 并行编译：没有依赖的命令可以并行执行。ninja默认使用的并行数为CPU数量，一般不用手动设置并行数，除非想限制ninja使用的CPU数量（例如有其他任务在运行，只让ninja用一半CPU）。
- 增量编译：根据文件的时间戳进行分析，如果某个文件的时间戳发生了改变，则依赖于这个文件的命令以及其他依赖于这个命令的命令都会被重新执行，以此达到增量编译的效果（比如修改了一个文件之后重新编译）。

它使用类似于 Makefile 的文本文件**build.ninja**描述构建过程，并通过 ninja 命令来执行构建。
## 安装ninja生成器
ninja是一个工具，而且体量很小。各个系统都有相关的安装方法，具体可参见文档:https://github.com/ninja-build/ninja/wiki/Pre-built-Ninja-packages。总的来说，有三种安装方式：

系统级安装：例如Ubuntu上面的apt-get install ninja-build、MacOS上面的brew install ninja，安装后ninja就是一个系统命令，类似ls/cat等命令。

用户级安装：例如通过pip或者conda都可以安装ninja: conda install ninja / pip install ninja

自定义安装：在GitHub下载页面:https://github.com/ninja-build/ninja/releases, 下载安装包并解压即可，或者下载源码自己编译。

## 指定ninja生成器
如果要使用 Ninja 来构建 CMake 项目，可以在生成构建脚本时使用 -G Ninja 选项
```
cmake -G Ninja -DCMAKE_BUILD_TYPE=Release path/to/project
```
其中, -DCMAKE_BUILD_TYPE 选项来指定构建类型，常见的构建类型有 Debug、Release 等。这个选项可以用来控制是否启用调试信息、优化等级等。


此外，CMake 还支持设置各种各样的变量，来控制构建过程。例如，可以使用 -DVARNAME=VALUE 选项来设置变量 VARNAME 的值为 VALUE。
例如，下面是使用 CMake 生成 Ninja 构建脚本，并设置一个名为 ENABLE_FOO 的布尔型变量的命令：
```
cmake -G Ninja -DENABLE_FOO=ON path/to/project
```
这些变量可以在 CMakeLists.txt 文件中使用，来控制构建过程。例如，你可以使用 if(ENABLE_FOO) 语句来判断 ENABLE_FOO 变量是否为真，然后决定是否编译某些源文件。

执行完会生成类似于Makefile的build.ninja文件

## 理解build.ninja文件
ninja的构建配置文件一般叫build.ninja。虽然我们一般不写它，但是需要大致看懂它，以便调试或者理解构建过程。

下面以一个简单的例子来说明常见的ninja配置：

有两个头文件a1.h和a2.h，分别定义了一个变量a，但是有不同的值：
```
// a1.h
int a = 1;

// a2.h
int a = 2;
```

一份源文件a.cpp里根据宏的不同来包含这两个文件中的某一个：
```
// a.cpp
#include<iostream>

using namespace ::std;

#ifdef USE_A1
#include "a1.h"
#endif

#ifdef USE_A2
#include "a2.h"
#endif

int main()
{
    cout << "hello, world from " << a << "!\n";
}
```

一份build.ninja文件包含ninja的构建配置（注意最后的换行，是必要的）：
```
# build.ninja
cxxflags = -DUSE_A1

rule compile
    description = compile with $cxxflags
    command = g++ -MM -MF $out.d -MT $out $cxxflags $in && g++ $cxxflags $in -o $out
    depfile = $out.d

build compile_with_default_cxxflags: compile a.cpp

build compile_with_shadow_cxxflags: compile a.cpp
    cxxflags = -DUSE_A2

default compile_with_default_cxxflags

```
这份配置里包含了以下常见内容：
- 注释（comment），build.ninja里用#开头的行表示注释，这个没什么好解释的。
- 变量（variable），cxxflags = -DUSE_A1定义了一个变量cxxflags，其值为-DUSE_A1。这个变量的值在后面的代码中都可以用，引用方式为$cxxflags。具体来说，-DUSE_A1就是在编译之前定义名为USE_A1的宏。
- 规则（rule），语法为rule 加上规则的名字。这里我们定义了一个名为compile的规则。规则内有默认变量$in和$out，$in表示输入文件的列表，$out表示输出文件名。
- 规则的文字描述（description），用于在编译过程中展示并告诉用户目前在干什么。
- 规则的具体命令（command），写明具体的编译命令。
- 规则的依赖项记录文件（depfile），用于增量编译，详见后面的解释。
- 构建（build），语法为build加上构建的文件名，加上冒号:以及规则名、输入文件列表。本质上build $out: $rule $in就是把$in和$out传给$rule，然后运行它的command命令。
- 构建里的局部变量，在build下面的任意变量，在本次构建命令中覆盖全局的变量。具体来说，build compile_with_shadow_cxxflags里定义的cxxflags会覆盖本次compile命令用到的cxxflags。
- 默认构建目标（default）。可以存在多行default，最后的默认构建目标就是它们的并集。如果没有任何default，则默认构建全部的build条目。

有了这份build.ninja，我们可以通过ninja或者ninja compile_with_default_cxxflags来构建默认的代码，得到可执行文件compile_with_default_cxxflags（执行后输出hello, world from 1!）；

也可以通过ninja compile_with_shadow_cxxflags得到可执行文件compile_with_shadow_cxxflags（执行后输出hello, world from 2!）。

我们也可以修改a1.h或者a2.h，观察ninja是否会重新编译。

## 生成可执行文件

cmake生成build.ninja之后, 就可以通过ninja命令生成可执行文件了, 可以使用 -j 选项来指定并行构建时使用的 CPU 核心数24个，使用 -v 选项来输出详细的构建信息。
```
ln28@DESKTOP-FS9U3GT:/mnt/d/Project/Cmake_examples/cmake_basics_10/build$ cmake .. -G Ninja  && ninja -j24 -v
-- Configuring done
-- Generating done
-- Build files have been written to: /mnt/d/Project/Cmake_examples/cmake_basics_10/build
[1/2] /usr/bin/c++     -MD -MT CMakeFiles/hello_cmake.dir/main.cpp.o -MF CMakeFiles/hello_cmake.dir/main.cpp.o.d -o CMakeFiles/hello_cmake.dir/main.cpp.o -c ../main.cpp
[2/2] : && /usr/bin/c++    -rdynamic CMakeFiles/hello_cmake.dir/main.cpp.o  -o hello_cmake   && :
ln28@DESKTOP-FS9U3GT:/mnt/d/Project/Cmake_examples/cmake_basics_10/build$ ./hello_cmake
Hello CMake!
ln28@DESKTOP-FS9U3GT:/mnt/d/Project/Cmake_examples/cmake_basics_10/build$
```

## 理解ninja的增量编译
这份build.ninja里的大部分内容简单易懂，唯一难以理解的就是用于增量编译的depfile = $out.d。

首先，$out是ninja的默认变量，表示构建的目标文件名。所以$out.d就是目标文件名加上.d。比如build compile_with_default_cxxflags里，depfile就是compile_with_default_cxxflags.d。

然后我们需要理解增量构建的目标：我们的build compile_with_default_cxxflags构建条目中，只传入了a.cpp这一个文件，但是实际上我们的代码里面包含了a1.h或者a2.h。如何能够让ninja知道增量构建的时候需要检查a1.h或者a2.h呢？这就需要编译器的支持了：g++的-MM -MF $out.d参数会将文件与头文件的依赖关系输出到$out.d中，下次ninja就会通过这个文件的内容来判断具体需要检查发生改变的文件。

例如，compile_with_default_cxxflags.d文件里，就有以下内容：
```
compile_with_default_cxxflags: a.cpp a1.h
```
下次ninja再build compile_with_default_cxxflags的时候，就会检查这个文件，然后查看a.cpp与a1.h的修改时间，如果任何一个文件被修改了，就重新编译。另外，如果compile_with_default_cxxflags文件不在了，ninja也会重新编译（这个很好理解）。

## ninja进阶用法
很多ninja.build里存在phony规则。这是一个内置规则，意思是“假冒的”，就是一个不存在规则的规则。我们可以理解为：
```
rule phony
    command = : $in $out
```

其中冒号:是unix系统里的一个命令，不管参数是什么，永远正常退出。因此，phony规则不会做什么，但是会在输入和输出之间建立依赖关系。

不带参数的ninja命令会构建文件里的default构建目标。我们也可以用ninja compile_with_shadow_cxxflags来手动构建某个目标。

构建多个目标（比如PyTorch有上千个目标）的时候，ninja会展示一个进度条，进度条展现的内容就是rule下面的description字段的内容。

ninja的高级用法一般都在ninja -t下面，例如

ninja -t clean可以清理全部生成文件

ninja -t browse可以打开一个网页浏览器查看文件之间的依赖图（默认查看的是名为all的依赖图）通过这个浏览器界面，我们可以很方便地查看什么文件依赖于什么文件。打开其中某一个http://localhost:8000/?libtorch.so就可以看到完整的libtorch.so对应的依赖，再也不用对着CMakeLists.txt瞎猜了。

还可以通过ninja -t graph直接导出依赖图的dot graph文件，但是大型项目的依赖图一般都非常复杂，看起来不方便。

最后，ninja -t targets all得到的是全部的构建目标，可以用于grep搜索想要的内容；ninja -C /path/to/dir -f /path/to/file可以让ninja切换到/path/to/dir去执行命令、并读取/path/to/file配置文件来执行。-f的默认参数是build.ninja，-C的默认参数为.，也就是当前路径。一般来说-f参数用得很少，-C参数用得比较多。